<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Flip & Posting Tool — Sortable (bundled offline)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;600&family=Roboto:wght@700&display=swap" rel="stylesheet">
<style>
  :root { --accent:#2ea44f; --danger:#dc3545; --muted:#b9bbbe; --panel:#2f3136; }
  html,body{height:100%;margin:0;background:#0f0f11;font-family:Montserrat,Arial,sans-serif;color:#fff;}
  /* container adjusted to fit viewport while keeping your visuals */
  #flipToolContainer{
    position:fixed; top:24px; left:50%; transform:translateX(-50%);
    width:760px; min-width:360px; max-width:96%;
    max-height: calc(100vh - 48px);
    border-radius:14px; z-index:999999; resize:both; overflow:auto;
    padding:14px; box-sizing:border-box; backdrop-filter: blur(8px);
    background: url("https://media.giphy.com/media/TjndRLCJ9KkF5etqAY/giphy.gif") center/cover no-repeat;
    box-shadow: 0 12px 30px rgba(0,0,0,0.6);
  }
  #toolHeader{height:96px; border-radius:10px; overflow:hidden; position:relative;
    margin:0 0 12px; background: url("https://media1.giphy.com/media/Y38iUdpAHYtBySPxGp/giphy.gif") center/contain no-repeat;}
  #toolHeader .title{position:absolute; left:0; right:0; top:0; bottom:0;
    display:flex; align-items:center; justify-content:center;
    font-family:Roboto,Arial,sans-serif; font-weight:700; font-size:22px;
    color:#fff; text-shadow:2px 2px 8px rgba(0,0,0,0.7); pointer-events:none;}
  .nav { display:flex; gap:8px; justify-content:center; margin-bottom:12px; }
  .nav button{ background:transparent; border:1px solid rgba(255,255,255,0.12); color:#fff; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; }
  .nav button.active{ border-color:rgba(255,255,255,0.25); background: linear-gradient(135deg,var(--accent),#20c99720); }
  label{ display:block; font-weight:600; color:#e6eef6; margin:8px 0 6px; font-size:13px; }
  input[type="text"], textarea, select{ width:100%; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.08);
    background: rgba(0,0,0,0.35); color:#fff; font-size:14px; box-sizing:border-box;}
  textarea{ min-height:80px; resize:vertical; }
  .row { display:flex; gap:10px; align-items:stretch; }
  .col{ flex:1; }
  .controls { text-align:center; margin-top:12px; }
  .btn { display:inline-block; padding: 12px 20px; min-width: 120px; border-radius: 10px; border:none; cursor:pointer;
    font-weight:700; font-size:14px; color:#fff; margin:6px; background: linear-gradient(135deg, #2ea44f, #20c997); transition:all 0.2s ease; text-align:center;}
  .btn:hover { filter: brightness(1.05); transform:translateY(-1px); }
  .close-btn {position:absolute; top:8px; right:8px; background:linear-gradient(135deg, #2ea44f, #20c997);
    border:none; color:#fff; font-weight:bold; font-size:14px; line-height:20px; width:28px; height:28px;
    border-radius:8px; cursor:pointer; text-align:center; padding:0; box-shadow:0 4px 10px rgba(0,0,0,0.4); transition:all 0.2s ease;}
  .close-btn:hover{filter:brightness(1.2); transform:scale(1.05);}

  /* Palette (kept but hidden; replaced by floating palettes) */
  #emojiPaletteWrap{ margin-top:12px; background: rgba(255,255,255,0.02); border-radius:8px; padding:10px; display:none; }
  #emojiPaletteHeader{ display:flex; align-items:center; justify-content:space-between; gap:8px; color:var(--muted); font-size:13px; }
  #emojiControls { display:flex; gap:8px; align-items:center; }
  #emojiAddBtn, #emojiSaveBtn { padding:6px 8px; border-radius:8px; border:1px dashed rgba(255,255,255,0.12); background:transparent; color:#fff; cursor:pointer; font-weight:700; }
  #emojiPalette{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; align-items:flex-start; min-height:44px; }

  .emoji-chip{ position:relative; user-select:none; display:inline-flex; align-items:center; justify-content:center; width:40px; height:40px; border-radius:10px; background:rgba(255,255,255,0.03); cursor:grab; font-size:20px; padding:6px; }
  .emoji-chip.dragging{ opacity:0.5; transform:scale(0.98); }


  /* Previews */
  .previewBar{ margin-top:16px; display:flex; align-items:center; gap:8px; color:var(--muted); font-weight:700; }
  .previewChip {
  border: 1px solid rgba(255,255,255,0.08);
  padding: 2px;
  border-radius: 8px;
  background: transparent;   /* transparent default */
  cursor: pointer;
  transition: all 0.2s ease;
}
.previewChip img {
  height: 28px;
  width: auto;
  border-radius: 6px;
  display: block;
}
.previewChip.active {
  background: linear-gradient(135deg,#202226,#2a2d31); /* subtle highlight */
  border-color: rgba(255,255,255,0.2);
}
.previewChip:hover {
  filter: brightness(1.1);
  transform: translateY(-1px);
}

  #previewsContainer{ margin-top:12px; display:grid; gap:10px; }

  .previewWrap{
  border-radius:10px;
  background:var(--panel);
  padding:12px;
  color:#dcddde;
  white-space:pre-wrap;
  position:relative;
  backdrop-filter: blur(4px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
  .previewHeader{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:6px; }
  .previewTitle{ font-weight:700; color:#fff; font-size:14px; }
  .previewFooter{ margin-top:8px; text-align:right; }
  .copyBtn { background:rgba(0,0,0,0.25); border:none; border-radius:6px; font-size:12px; padding:6px 10px; cursor:pointer; color:#fff; }
  .copyBtn:hover { background:rgba(255,255,255,0.04); }

  /* floating palette panels */
  .floating-palette{
    position:fixed;
    right:18px;
    width:220px;
    min-width:160px;
    max-width:36%;
    min-height:56px;
    background:linear-gradient(180deg, rgba(20,20,22,0.85), rgba(30,30,32,0.78));
    border-radius:12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    backdrop-filter: blur(8px);
    padding:8px;
    z-index:1000000;
    overflow:auto;
    resize:both;
  }
  .floating-palette .pal-header{
    display:flex; align-items:center; justify-content:space-between; gap:8px;
    cursor:move; user-select:none; padding:4px 6px; border-radius:8px;
  }
  .floating-palette .pal-title{ font-weight:700; font-size:13px; color:#fff; }
  .floating-palette .pal-controls{ display:flex; gap:6px; align-items:center; }
  .floating-palette .pal-controls button{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:#fff; border-radius:8px; padding:4px 6px; cursor:pointer; font-weight:700; }
  .floating-palette .pal-body{ margin-top:8px; display:flex; flex-wrap:wrap; gap:8px; }

  /* floating preview windows - match style */
  .floating-preview{
  position:fixed;
  right:18px;
  width:340px;
  min-width:200px;
  background:linear-gradient(180deg, rgba(20,20,22,0.9), rgba(30,30,32,0.8));
  border-radius:12px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.6);
  backdrop-filter: blur(8px);
  padding:8px;
  z-index:1000000;
  resize:both;
  overflow:auto;

  /* add transition for smooth positioning */
  transition: left 0.15s ease, top 0.15s ease;

}
.floating-preview .fp-header{
  display:flex; align-items:center; justify-content:space-between;
  cursor:move; user-select:none; padding:4px 6px; border-radius:8px;
}
.floating-preview .fp-title{
  font-weight:700; font-size:13px; color:#fff;
  display:flex; align-items:center; gap:6px;
}
.floating-preview .fp-title img{ height:28px; width:auto; border-radius:4px; }
.floating-preview .fp-controls{ display:flex; gap:6px; align-items:center; }
.floating-preview .fp-controls button{ background:transparent; border:1px solid rgba(255,255,255,0.1); color:#fff; border-radius:8px; padding:4px 6px; cursor:pointer; font-weight:700; font-size:12px; }
.floating-preview .fp-body{ margin-top:8px; color:#dcddde; white-space:pre-wrap; }


  /* small helper */
  .muted{ color:var(--muted); font-size:13px; }
  .inline{ display:inline-flex; align-items:center; gap:8px; }

  @media (max-width:640px){
    #flipToolContainer{ width:96%; left:2%; transform:none; top:12px; padding:10px; max-height: calc(100vh - 24px); }
    .row{ flex-direction:column; }
    .emoji-chip{ width:36px; height:36px; }
    .floating-palette{ right:8px; left:8px; width:auto; max-width:unset; }
  }

.editableDiv {
  min-height:80px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.08);
  background: rgba(0,0,0,0.35);
  color:#fff;
  font-size:14px;
  padding:8px 10px;
  overflow-y:auto;
  white-space:pre-wrap;
}
.editableDiv:empty:before {
  content: attr(placeholder);
  color: #b9bbbe;
}

/* tiny handle icons */
.icon-btn { background:transparent;border:none;color:#fff;cursor:pointer;padding:4px;border-radius:6px;font-weight:700;border:1px solid rgba(255,255,255,0.04); }
.icon-btn:hover{ filter:brightness(1.1); transform:translateY(-1px); }

/* Small standardized X button for all uses */
.small-x-btn {
  width: 18px;
  height: 18px;
  font-size: 12px;
  line-height: 18px;
  border-radius: 50%;
  background: #ff4757;  /* main tool default red */
  color: #fff;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  position: absolute;
  top: -6px;
  right: -6px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
  user-select: none;
}
.small-x-btn:hover {
  filter: brightness(1.2);
  transform: scale(1.05);
}

/* Emoji chip X buttons inside palette (small round, header-style) */
.floating-palette .emoji-chip .small-x-btn {
  width: 14px;               /* smaller */
  height: 14px;
  font-size: 10px;
  line-height: 14px;
  top: -4px;
  right: -4px;
  background: rgba(255,255,255,0.08);  /* same style as Save/Clear/Close */
  color: #fff;
}
.floating-palette .emoji-chip .small-x-btn:hover {
  background: rgba(255,255,255,0.15); /* slightly brighter on hover */
}

/* Posting tool Export button style — matches header nav buttons but smaller */
.controls .nav-btn {
  font-weight:600;
  font-size:13px;
  padding:6px 12px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.12);
  background: linear-gradient(135deg,var(--accent),#20c99720);
  cursor:pointer;
  color:#fff;
  transition: all 0.2s ease;
  margin:4px;
}

.controls .nav-btn:hover {
  filter: brightness(1.1);
  transform: translateY(-1px);
}

/* show move cursor on header for clarity */
#toolHeader { cursor: move; user-select: none; }


</style>
</head>
<body>
<div id="flipToolContainer" role="dialog" aria-label="Flip Tool">
  <div id="toolHeader">
    <button class="close-btn" id="closeToolBtn">×</button>
  </div>

  <div class="nav">
    <button id="navFlip" class="active">Flip Tool</button>
    <button id="navPost">Posting Tool</button>
  </div>

  <!-- Flip Page -->
  <div id="pageFlip">
    <label>Enter Search</label>
    <input type="text" id="flipInput" placeholder="keyword or UPC">
    <div class="row">
      <div class="col">
        <label>Category</label>
        <select id="flipCategory">
          <option value="online">Online Flip</option>
          <option value="local">Local Flip</option>
          <option value="store">Store Search</option>
        </select>
      </div>
      <div class="col">
        <label>Site</label>
        <select id="flipSite"></select>
      </div>
    </div>
    <div class="controls">
      <button id="flipSearch" class="nav-btn">Search</button>
      <button id="closeTool" class="nav-btn">Close</button>
    </div>
  </div>

  <!-- Posting Page -->
  <div id="pagePost" style="display:none;">
    <label>Product Title</label>
    <input type="text" id="productTitle" placeholder="Full product title">

    <label>Store Link</label>
    <input type="text" id="productLink" placeholder="https://...">

    <div class="row">
      <div class="col">
        <label>Retail</label>
        <input type="text" id="retailInput" placeholder="$xx.xx">
      </div>
      <div class="col">
        <label>Resell</label>
        <input type="text" id="resellInput" placeholder="$xx.xx">
      </div>
    </div>

    <label>eBay Comps</label>
    <input type="text" id="compsLink" placeholder="https://...">

    <label>Notes</label>
<div id="productNotes" contenteditable="true" class="editableDiv" placeholder="Optional notes — click emojis to insert where cursor is"></div>

    <!-- ORIGINAL in-tool palette is hidden (replaced by floating palettes) -->
    <div id="emojiPaletteWrap" aria-hidden="true"></div>

    <!-- Preview chips -->
<div class="previewBar">
  <div class="muted">Preview:</div>
  <div id="chip1" class="previewChip">
    <img src="https://media.giphy.com/media/U8ZZd3UbHWw6Qc0hzb/giphy.gif" alt="eMoney">
  </div>
  <div id="chip2" class="previewChip">
    <img src="https://media.giphy.com/media/xKyHBT3fiCel8mIO4P/giphy.gif" alt="Viral Bricks">
  </div>
  <div id="chip3" class="previewChip">
    <img src="https://media.giphy.com/media/LD4EpMy6oXzG0lcbnL/giphy.gif" alt="Reselling Secrets">
  </div>
  <div style="flex:1"></div>
  <div class="muted">KrisTool🤖²°²⁵</div>
</div>


    <div id="previewsContainer" style="display:none;"></div>

<div class="controls">
  <button id="clearBtn" class="nav-btn">Clear All</button>
  <button id="exportHTMLBtn" class="nav-btn">Export</button>

</div>

  </div>
</div>

<script>
/* helper */
const $ = id => document.getElementById(id);
const previewGIFs = {
  1: "https://media.giphy.com/media/U8ZZd3UbHWw6Qc0hzb/giphy.gif",
  2: "https://media.giphy.com/media/xKyHBT3fiCel8mIO4P/giphy.gif",
  3: "https://media.giphy.com/media/LD4EpMy6oXzG0lcbnL/giphy.gif"
};
const previewNames = {
  1: "",
  2: "",
  3: ""
};
const PALETTES = {
  palette_eMoney: [
    { emoji: '💵', alias: '' },
    { emoji: '🤑', alias: '' }
  ],
  palette_resellingSecrets: [
    { emoji: '🔥', alias: '' },
    { emoji: '⚠️', alias: '' }
  ],
  palette_viralBricks: [
    { emoji: '💰', alias: '' },
    { emoji: '📊', alias: '' }
  ]
};

function escapeHtml(s){ if(s===undefined||s===null) return ""; return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }

let lastFocusedInput = null;
document.querySelectorAll('input[type="text"], textarea, [contenteditable="true"]').forEach(el => {
  el.addEventListener('focus', () => {
    lastFocusedInput = el;
  });
});

/* ---- Flip tool site lists (restored full mapping) ---- */
const siteMap = {
  online: [
    {value:"ebay",text:"eBay Sold"},
    {value:"mercari",text:"Mercari"},
    {value:"watchcount",text:"WatchCount"},
    {value:"goat",text:"GOAT"},
    {value:"stockx",text:"StockX"}
  ],
  local: [
    {value:"offerup",text:"OfferUp"},
    {value:"fbmarket",text:"Facebook Marketplace"},
    {value:"craigslist",text:"Craigslist"},
    {value:"nextdoor",text:"Nextdoor"},
    {value:"letgo",text:"Letgo"}
  ],
  store: [
    {value:"gamestop",text:"GameStop"},
    {value:"bestbuy",text:"BestBuy"},
    {value:"amazon",text:"Amazon"},
    {value:"walmart",text:"Walmart"},
    {value:"target",text:"Target"},
    {value:"costco",text:"Costco"},
    {value:"samsclub",text:"Sam's Club"},
    {value:"lowes",text:"Lowe's"},
    {value:"homedepot",text:"Home Depot"}
  ]
};
function populateSites(cat){ const sel = $('flipSite'); sel.innerHTML=''; siteMap[cat].forEach(it=>{ const o = document.createElement('option'); o.value = it.value; o.textContent = it.text; sel.appendChild(o); }); }
populateSites('online'); $('flipCategory').addEventListener('change', ()=> populateSites($('flipCategory').value) );

/* flip search */
$('flipSearch').addEventListener('click', ()=>{
  const q = $('flipInput').value.trim(); if(!q){ alert('Enter a keyword or UPC'); return; }
  const s = $('flipSite').value; let u="";
  if(s==="ebay")u="https://www.ebay.com/sch/i.html?_nkw="+encodeURIComponent(q)+"&LH_Sold=1&LH_Complete=1";
  else if(s==="mercari")u="https://www.mercari.com/search/?itemStatuses=2-3&keyword="+encodeURIComponent(q);
  else if(s==="watchcount")u="https://www.watchcount.com/sold/"+encodeURIComponent(q)+"/-/all";
  else if(s==="goat")u="https://www.goat.com/search?query="+encodeURIComponent(q);
  else if(s==="stockx")u="https://stockx.com/search?s="+encodeURIComponent(q);
  else if(s==="offerup")u="https://offerup.com/search/?query="+encodeURIComponent(q);
  else if(s==="fbmarket")u="https://www.facebook.com/marketplace/search/?query="+encodeURIComponent(q);
  else if(s==="craigslist")u="https://www.craigslist.org/search/sss?query="+encodeURIComponent(q);
  else if(s==="nextdoor")u="https://nextdoor.com/news_feed/?query="+encodeURIComponent(q);
  else if(s==="letgo")u="https://www.letgo.com/arama?query_text="+encodeURIComponent(q);
  else if(s==="gamestop")u="https://www.gamestop.com/search/?q="+encodeURIComponent(q);
  else if(s==="bestbuy")u="https://www.bestbuy.com/site/searchpage.jsp?st="+encodeURIComponent(q);
  else if(s==="amazon")u="https://www.amazon.com/s?k="+encodeURIComponent(q)+"&tag=amzlnk05-20";
  else if(s==="walmart")u="https://www.walmart.com/search/?query="+encodeURIComponent(q);
  else if(s==="target")u="https://www.target.com/s?searchTerm="+encodeURIComponent(q);
  else if(s==="costco")u="https://www.costco.com/CatalogSearch?keyword="+encodeURIComponent(q);
  else if(s==="samsclub")u="https://www.samsclub.com/s/search="+encodeURIComponent(q);
  else if(s==="lowes")u="https://www.lowes.com/search?searchTerm="+encodeURIComponent(q);
  else if(s==="homedepot")u="https://www.homedepot.com/s/"+encodeURIComponent(q);
  if(u) window.open(u,'_blank');
});

// Trigger flip search on Enter key
$('flipInput').addEventListener('keydown', e => {
  if(e.key === 'Enter'){
    e.preventDefault();
    $('flipSearch').click();
  }
});


/* Nav */
$('navFlip').addEventListener('click', ()=>{ $('pageFlip').style.display='block'; $('pagePost').style.display='none'; $('navFlip').classList.add('active'); $('navPost').classList.remove('active'); });
$('navPost').addEventListener('click', ()=>{ $('pageFlip').style.display='none'; $('pagePost').style.display='block'; $('navFlip').classList.remove('active'); $('navPost').classList.add('active'); });

/* Close */
$('closeTool')?.addEventListener('click', ()=> { $('flipToolContainer').remove(); });
$('closeToolBtn')?.addEventListener('click', ()=> { $('flipToolContainer').remove(); });


/* ---------------- Insert helper (keeps existing behavior) ---------------- */
function insertAtCursorIntoFocused(html) {
  const el = lastFocusedInput;
  if (!el) return;

  if(el.isContentEditable){
    const sel = window.getSelection();
    if(!sel.rangeCount) return;
    const range = sel.getRangeAt(0);
    range.deleteContents();

    // Create a fragment for HTML content
    const frag = document.createDocumentFragment();
    const temp = document.createElement('div');
    temp.innerHTML = html;
    while(temp.firstChild){
      frag.appendChild(temp.firstChild);
    }

    range.insertNode(frag);
    // Move cursor to after inserted content
    range.collapse(false);
    sel.removeAllRanges();
    sel.addRange(range);
    el.focus();
  } else {
    // fallback for input/textarea
    const start = el.selectionStart;
    const end = el.selectionEnd;
    const value = el.value;
    el.value = value.slice(0,start) + html + value.slice(end);
    el.selectionStart = el.selectionEnd = start + html.length;
    el.focus();
  }
}

/* ---------------- Markdown/preview helpers (existing) ---------------- */
function mdToHtml(md){
  if(!md) return '';
  let s = md;

  // Convert Discord-style <a?:emoji:id> into <img> for preview
s = s.replace(/<(a?):([^:]+):(\d+)>/g, (m, a, name, id) => {
  const ext = a === 'a' ? 'gif' : 'png';
  return `<img src="https://cdn.discordapp.com/emojis/${id}.${ext}" style="width:20px;height:20px;vertical-align:text-bottom;">`;
});

  // Escape only text nodes, keep <img> intact
const tempDiv = document.createElement('div');
tempDiv.innerHTML = s;
function escapeNodes(node){
  node.childNodes.forEach(child=>{
    if(child.nodeType === 3) child.textContent = escapeHtml(child.textContent);
    else if(child.nodeType === 1 && child.tagName !== 'IMG') escapeNodes(child);
  });
}
escapeNodes(tempDiv);
s = tempDiv.innerHTML;


  // **bold**
  s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

  // [link](url)
  s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');

  // `inline code`
  s = s.replace(/`([^`]+)`/g, '<code style="background:#2f3136; color:#fff; padding:0 4px; border-radius:4px; font-family:Consolas,monospace; font-size:13px;">$1</code>');

  // line breaks
  s = s.replace(/\r?\n/g, '<br>');

  return s;
}


function getStoreLabel(url){
  try{
    const u=new URL(url);
    let n=u.hostname.replace(/^www\./,'').split('.')[0];
    return n.charAt(0).toUpperCase()+n.slice(1);
  }catch(e){
    return 'Store';
  }
}

// 👇 ADD THIS BLOCK
function normalizeAmazonLink(link) {
  if (!link) return "";
  let url = link.startsWith("http") ? link : "https://" + link;
  if (url.includes("amazon.")) {
    // remove any existing tag first
    url = url.replace(/([?&])tag=[^&]+/, '');
    // add your affiliate tag
    url += (url.includes("?") ? "&" : "?") + "tag=amzlnk05-20";
  }
  return url;
}

function buildPreview(which){
  const title = $('productTitle').value.trim();
  const retail = $('retailInput').value.trim();
  const resell = $('resellInput').value.trim();
  const link = $('productLink').value.trim();
  const comps = $('compsLink').value.trim();
  let notesRaw = $('productNotes').innerHTML.trim();
  let notes = convertDiscordImgsToCodes(notesRaw); // turn <img> into <:name:id>

  // ✅ use affiliate safe link
  const linkNorm = normalizeAmazonLink(link);
  const compsNorm = comps ? (comps.startsWith('http')?comps:'https://'+comps) : '';
  const storeLabel = linkNorm ? getStoreLabel(linkNorm) : 'Store';

  let md = '';
  if(which === 1){
    md += `**${title}**\n`;
    if(linkNorm) md += `Where: [${storeLabel}](${linkNorm})\n`;
    if(retail) md += `Retail: ${retail}\n`;
    if(resell) md += `Resell: ${resell}\n`;
    if(notes) md += `Notes: ${notes}\n`;
    if(compsNorm) md += `[eBay Comps](${compsNorm})\n`;
  } else if(which === 2){
    md += `**${title}**  \n`;
    md += `\`Store:\` ${storeLabel} | ${linkNorm ? `[Link](${linkNorm})` : ''}\n`;
    if(retail) md += `\`Retail:\` ${retail}  \n`;
    if(resell) md += `\`Resell:\` ${resell}  \n`;
    if(notes) md += `\`Notes:\` ${notes}\n`;
    if(compsNorm) md += `[Comps](${compsNorm})\n`;
  } else if(which === 3){
    md += `**${title}**  \n`;
    if(retail) md += `Retail: ${retail} [${storeLabel}](${linkNorm}) | Resell: ${resell}\n`;
    if(compsNorm) md += `[Comps Here](${compsNorm})\n`;
    if(notes) md += `Notes: ${notes}\n`;
  }
  return md;
}

function convertDiscordImgsToCodes(htmlString) {
  const temp = document.createElement('div');
  temp.innerHTML = htmlString;

  temp.querySelectorAll('img[data-id]').forEach(img => {
    const id = img.getAttribute('data-id');
    const name = img.getAttribute('data-name') || `emoji${id}`;
    const animated = img.getAttribute('data-animated') === 'true' ? 'a' : '';
    const code = `<${animated}:${name}:${id}>`;
    img.replaceWith(code);
  });

  return temp.textContent || temp.innerHTML;
}

/* ---------------- floating palettes (3) ---------------- */
const FLOATING_PALETTES = [
  { key: 'palette_eMoney', gif: 'https://media.giphy.com/media/U8ZZd3UbHWw6Qc0hzb/giphy.gif', color: '#2ea44f' },
  { key: 'palette_resellingSecrets', gif: 'https://media.giphy.com/media/LD4EpMy6oXzG0lcbnL/giphy.gif', color: '#20c997' },
  { key: 'palette_viralBricks', gif: 'https://media.giphy.com/media/xKyHBT3fiCel8mIO4P/giphy.gif', color: '#ff6b6b' }
];

function readPaletteLocal(key) {
  return PALETTES[key] || [];
}

function writePaletteLocal(key, arr) {
  PALETTES[key] = arr;
}

function createPalettePanel(spec, index){
  const existing = document.getElementById(spec.key);
  if(existing) return existing;

  const panel = document.createElement('div');
  panel.className = 'floating-palette';
  panel.id = spec.key;

  // Position stacked vertically on right
  const topOffset = 18 + (index * 140);
  panel.style.top = `${topOffset}px`;

  // header
  const header = document.createElement('div');
  header.className = 'pal-header';
header.innerHTML = `<div class="pal-title">
  <img src="${spec.gif}" style="height:28px; width:auto; border-radius:6px;">
</div>
<div class="pal-controls">
  <button class="icon-btn" title="Save">💾</button>
  <button class="icon-btn" title="Clear">🗑</button>
  <button class="icon-btn" title="Close">✕</button>
</div>`;
  panel.appendChild(header);

  const body = document.createElement('div');
  body.className = 'pal-body';
  panel.appendChild(body);

  // add input row
  const addRow = document.createElement('div');
  addRow.style.marginTop = '8px';
  addRow.innerHTML = `<input placeholder="Add emoji or URL" style="width:calc(100% - 48px);padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#fff;">
  <button class="icon-btn" style="margin-left:6px;">＋</button>`;
  panel.appendChild(addRow);

  document.body.appendChild(panel);

  // load & render
  function render(){
    body.innerHTML = '';
    const arr = readPaletteLocal(spec.key) || [];
    arr.forEach((entry, idx) => {
      const chip = document.createElement('div');
      chip.className = 'emoji-chip';
      chip.style.width = '36px';
      chip.style.height = '36px';
      chip.style.fontSize = '18px';
      chip.style.display = 'inline-flex';
      chip.style.alignItems = 'center';
      chip.style.justifyContent = 'center';
      chip.style.borderRadius = '8px';
      chip.style.background = 'rgba(255,255,255,0.02)';
      chip.style.cursor = 'pointer';
      chip.title = entry.alias || 'Click to insert';
      chip.setAttribute('data-idx', idx);

      if(/^https?:\/\//.test(entry.emoji)){
        const img = document.createElement('img');
        img.src = entry.emoji;
        img.style.width='28px';
        img.style.height='28px';
        img.style.objectFit='contain';
        chip.appendChild(img);
      } else {
        chip.textContent = entry.emoji;
      }

      // click to insert
      chip.addEventListener('click', (ev)=>{
        ev.stopPropagation();
        let toInsert = entry.emoji;
        const alias = entry.alias || '';

        if (/^https?:\/\//.test(toInsert)) {
          // fallback for images
          toInsert = `<img src="${toInsert}" data-name="${alias}" style="width:20px;height:20px;vertical-align:text-bottom;">`;
        }

        insertAtCursorIntoFocused(toInsert);
      });

      // draggable reorder
      chip.draggable = true;
      chip.addEventListener('dragstart', (e)=> {
        e.dataTransfer.setData('text/plain', idx);
        chip.classList.add('dragging');
      });
      chip.addEventListener('dragend', ()=> chip.classList.remove('dragging'));

      // allow drop reordering on body
      chip.addEventListener('dragover', (ev)=> ev.preventDefault());
      chip.addEventListener('drop', (ev)=>{
        ev.preventDefault();
        const fromIdx = Number(ev.dataTransfer.getData('text/plain'));
        const toIdx = idx;
        if(isNaN(fromIdx)) return;
        const arr = readPaletteLocal(spec.key);
        const [moved] = arr.splice(fromIdx,1);
        arr.splice(toIdx,0,moved);
        writePaletteLocal(spec.key, arr);
        render();
      });

      // small remove button (emoji palette)
const rm = document.createElement('div');
rm.className = 'small-x-btn';   // shared style
rm.textContent = '×';
rm.title = 'Remove';
rm.addEventListener('click', (e) => {
  e.stopPropagation();               // prevent triggering chip click
  const arr = readPaletteLocal(spec.key);
  arr.splice(idx, 1);                // remove this emoji from palette
  writePaletteLocal(spec.key, arr);  // save updated palette
  render();                           // re-render palette to reflect changes
});

// ensure chip itself is positioned relative so X sits correctly
chip.style.position = 'relative';
chip.appendChild(rm);

// append chip to palette body
body.appendChild(chip);
    });

    // if empty, show a faint hint
    if(arr.length === 0){
      const note = document.createElement('div');
      note.className = 'muted';
      note.style.fontSize = '12px';
      note.style.opacity = '0.75';
      note.style.padding = '6px 0';
      note.textContent = 'Empty — add emoji or image URL';
      body.appendChild(note);
    }
  }

  // actions
  const saveBtn = header.querySelector('.icon-btn[title="Save"]');
  const clearBtn = header.querySelector('.icon-btn[title="Clear"]');
  const closeBtn = header.querySelector('.icon-btn[title="Close"]');
  const addInput = addRow.querySelector('input');
  const addBtn = addRow.querySelector('button');

  saveBtn.addEventListener('click', ()=>{
    // saving already automatic; show quick feedback
    panel.animate([{transform:'scale(1)'},{transform:'scale(0.98)'},{transform:'scale(1)'}],{duration:160});
    // persist is immediate via writePaletteLocal when changes occur
  });

  clearBtn.addEventListener('click', ()=>{
    if(!confirm(`Clear ${spec.title} palette?`)) return;
    writePaletteLocal(spec.key, []);
    render();
  });

  closeBtn.addEventListener('click', ()=> {
    panel.style.display = 'none';
  });

  addBtn.addEventListener('click', ()=>{
    const v = addInput.value.trim();
    if(!v) return;
    const arr = readPaletteLocal(spec.key);
    // If user entered format "URL:alias" or "emoji:alias"
    let emoji = v, alias = '';
    const colonIndex = v.lastIndexOf(':');
    if(colonIndex > 0 && !/^https?:\/\//.test(v)){
      emoji = v.slice(0, colonIndex);
      alias = v.slice(colonIndex+1);
    }
    arr.push({ emoji, alias });
    writePaletteLocal(spec.key, arr);
    addInput.value = '';
    render();
  });

  addInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){ addBtn.click(); e.preventDefault(); }
  });

  // drag header to move panel
  header.addEventListener('mousedown', (e)=>{
    if(e.target.tagName.toLowerCase() === 'button') return; // don't start drag if clicked buttons
    const startX = e.clientX, startY = e.clientY;
    const rect = panel.getBoundingClientRect();
    const offsetX = startX - rect.left, offsetY = startY - rect.top;
    function onMove(ev){
      panel.style.left = (ev.clientX - offsetX) + 'px';
      panel.style.top = (ev.clientY - offsetY) + 'px';
      panel.style.right = 'auto';
    }
    function onUp(){
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
    }
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  });

  // persist position & size optionally (not required), but we keep default stacking
  render();
  return panel;
}



/* ---------------- Floating previews (spawn only when chip toggled) ---------------- */
const activeFloatingPreviews = {}; // map which->element

// helper to create/move a floating preview
function ensureFloatingPreview(which){
  const id = `floatingPreview${which}`;
  if(activeFloatingPreviews[which] && document.body.contains(activeFloatingPreviews[which])) return activeFloatingPreviews[which];

  const fp = document.createElement('div');
  fp.className = 'floating-preview';
  fp.id = id;
  // default position - near center but offset for each index
  fp.style.top = (100 + (which * 36)) + 'px';
  fp.style.left = (80 + (which * 28)) + 'px';

  const header = document.createElement('div');
  header.className = 'fp-header';
  header.innerHTML = `
  <div class="fp-title">
    <img src="${previewGIFs[which]}"> ${previewNames[which]}
  </div>
  <div class="fp-controls">
    <button class="icon-btn" title="Copy">Copy</button>
    <button class="icon-btn" title="Close">✕</button>
  </div>`;

  fp.appendChild(header);

  const body = document.createElement('div');
  body.className = 'fp-body';
  fp.appendChild(body);

  // copy handler
  header.querySelector('.icon-btn[title="Copy"]').addEventListener('click', ()=>{
    const md = buildPreviewMarkdown(which);
    // convert simple HTML back to markdown-ish
    const mdForDiscord = md.replace(/<br\s*\/?>/g,'\n').replace(/<\/?strong>/g,'**');
    navigator.clipboard.writeText(mdForDiscord).then(()=> {
      header.animate([{transform:'scale(1)'},{transform:'scale(0.98)'},{transform:'scale(1)'}],{duration:160});
      try{ alert('Preview copied to clipboard'); }catch(e){}
    });
  });

  // close handler
  header.querySelector('.icon-btn[title="Close"]').addEventListener('click', ()=>{
    // toggle chip off
    const chip = $(`chip${which}`);
    if(chip) chip.classList.remove('active');
    fp.remove();
    delete activeFloatingPreviews[which];
  });

  document.body.appendChild(fp);
  activeFloatingPreviews[which] = fp;

  // drag header to move fp
  header.addEventListener('mousedown', (e)=>{
    if(e.target.tagName.toLowerCase() === 'button') return;
    const rect = fp.getBoundingClientRect();
    const offsetX = e.clientX - rect.left, offsetY = e.clientY - rect.top;
    function onMove(ev){ fp.style.left = (ev.clientX - offsetX) + 'px'; fp.style.top = (ev.clientY - offsetY) + 'px'; }
    function onUp(){ window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); }
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  });

  // live update on input changes handled elsewhere

  return fp;
}

function removeFloatingPreview(which){
  const el = activeFloatingPreviews[which];
  if(el){ el.remove(); delete activeFloatingPreviews[which]; }
}

function updateFloatingPreviewContent(which){
  const el = activeFloatingPreviews[which];
  if(!el) return;
  const body = el.querySelector('.fp-body');
  body.innerHTML = mdToHtml(buildPreview(which));
}

// hook preview chips to spawn/close floating previews + toggle emoji palettes
const chipMap = {'chip1':1,'chip2':2,'chip3':3};
Object.keys(chipMap).forEach(chipId=>{
  const chip = $(chipId);
  if(!chip) return;
  chip.setAttribute('role','button');
  chip.setAttribute('aria-pressed','false');
  chip.addEventListener('click', ()=> {
  chip.classList.toggle('active');
  chip.setAttribute('aria-pressed', chip.classList.contains('active'));
  const which = chipMap[chipId];

  if(chip.classList.contains('active')){
    // spawn floating preview
    const fp = ensureFloatingPreview(which);
    updateFloatingPreviewContent(which);

    // also show matching palette
    const spec = FLOATING_PALETTES[which-1]; // match chip index to palette
    let panel = document.getElementById(spec.key);
    if (!panel) {
      panel = createPalettePanel(spec, which-1);
    }
    panel.style.display = 'block';

    // **Position side by side**
    const fpRect = fp.getBoundingClientRect();
    panel.style.top = fpRect.top + 'px';
    panel.style.left = (fpRect.right + 8) + 'px'; // 8px gap
    panel.style.right = 'auto'; // remove previous right
} else {
    // remove preview
    removeFloatingPreview(which);

    // also hide palette
    const spec = FLOATING_PALETTES[which-1];
    const panel = document.getElementById(spec.key);
    if(panel) panel.style.display = 'none';
}
});
});

// update all active floating previews when inputs change
function updateAllFloatingPreviews(){
  [1,2,3].forEach(n=>{
    if(activeFloatingPreviews[n]) updateFloatingPreviewContent(n);
  });
}

/* wire inputs for live preview updates (so floating previews update live) */
const liveInputs = ['productTitle','productLink','productNotes','compsLink','retailInput','resellInput'];
liveInputs.forEach(id=>{
  const el = $(id);
  if(!el) return;
  el.addEventListener('input', updateAllFloatingPreviews);
  el.addEventListener('change', updateAllFloatingPreviews);
});

// also update on focus changes (in case insertAtCursorIntoFocused used)
document.addEventListener('selectionchange', updateAllFloatingPreviews);

/* ---------------- Clear button behavior ---------------- */
$('clearBtn').addEventListener('click', ()=>{
  if(confirm('Clear all emojis and notes from the palette?')){
    // clear floating palettes data but do not remove panels
    FLOATING_PALETTES.forEach(p=> writePaletteLocal(p.key, []));
    FLOATING_PALETTES.forEach(p=> {
      const panel = document.getElementById(p.key);
      if(panel){
        // re-render body
        panel.querySelectorAll('.pal-body, input').forEach(el=>el.remove());
      }
    });
    // clear notes too
    const notesDiv = document.getElementById('productNotes');
    if(notesDiv){ notesDiv.innerHTML = ''; localStorage.removeItem('productNotes'); }
    // refresh palettes (recreate)
    FLOATING_PALETTES.forEach((p, idx)=> {
      const panel = document.getElementById(p.key);
      if(panel) panel.remove();
      createPalettePanel(p, idx);
    });
  }
});

/* Save productNotes to localStorage like before */
const notesDiv = document.getElementById('productNotes');
const savedNotes = localStorage.getItem('productNotes');
if(savedNotes) notesDiv.innerHTML = savedNotes;
notesDiv.addEventListener('input', () => {
  localStorage.setItem('productNotes', notesDiv.innerHTML);
  updateAllFloatingPreviews();
});


/* ---------------- ensure previews reflect initial state on page load if chips active ---------------- */
window.addEventListener('load', ()=>{
  // if chips were previously active (class persisted?), spawn previews — we don't persist chip state now, but check anyway
  [1,2,3].forEach(n=>{
    const chip = $(`chip${n}`);
    if(chip && chip.classList.contains('active')) {
      ensureFloatingPreview(n);
      updateFloatingPreviewContent(n);
    }
  });
});

/* ---------------- keep everything else intact (no other structural changes) ---------------- */


$('exportHTMLBtn').addEventListener('click', ()=> {
  // Serialize the updated PALETTES object
  const palettesScript = `<script>\nconst PALETTES = ${JSON.stringify(PALETTES, null, 2)};\n<\/script>`;

  // Grab current HTML content
  const doc = document.documentElement.outerHTML;

  // Replace the old PALETTES definition with the new one
  const updatedHTML = doc.replace(/<script>\s*const PALETTES = [\s\S]*?<\/script>/, palettesScript);

  // Create a Blob and download
  const blob = new Blob([updatedHTML], {type: 'text/html'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'flip_post_tool_updated.html';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  alert('Updated HTML downloaded. Open this file to retain changes.');
});

// Make the whole tool draggable by dragging the header (mouse + touch)
function makeElementDraggable(el, handle) {
  if (!el || !handle) return;

  let isDragging = false;
  let startX = 0, startY = 0;
  let startLeft = 0, startTop = 0;

  function onDown(clientX, clientY) {
    isDragging = true;
    const rect = el.getBoundingClientRect();
    startX = clientX;
    startY = clientY;
    // capture the current left/top in pixels
    startLeft = rect.left;
    startTop = rect.top;
    // remove right so we can set left
    el.style.right = 'auto';
    el.style.transform = 'none'; // cancel translateX(-50%) when dragging
    el.style.left = `${startLeft}px`;
    el.style.top = `${startTop}px`;
  }

  function onMove(clientX, clientY) {
    if (!isDragging) return;
    const dx = clientX - startX;
    const dy = clientY - startY;
    el.style.left = `${startLeft + dx}px`;
    el.style.top = `${startTop + dy}px`;
  }

  function onUp() {
    isDragging = false;
  }

  // mouse events
  handle.addEventListener('mousedown', (e) => {
    // don't start drag when clicking a button or interactive element inside header
    if (e.target.closest('button, a, input, textarea')) return;
    e.preventDefault();
    onDown(e.clientX, e.clientY);
    window.addEventListener('mousemove', mouseMove);
    window.addEventListener('mouseup', mouseUp);
  });

  function mouseMove(e){ onMove(e.clientX, e.clientY); }
  function mouseUp(e){ onUp(); window.removeEventListener('mousemove', mouseMove); window.removeEventListener('mouseup', mouseUp); }

  // touch events
  handle.addEventListener('touchstart', (e) => {
    if (e.target.closest('button, a, input, textarea')) return;
    const t = e.touches[0];
    onDown(t.clientX, t.clientY);
    window.addEventListener('touchmove', touchMove, {passive:false});
    window.addEventListener('touchend', touchEnd);
  }, {passive:false});

  function touchMove(e){
    if(!isDragging) return;
    e.preventDefault(); // prevent scrolling while dragging
    const t = e.touches[0];
    onMove(t.clientX, t.clientY);
  }
  function touchEnd(){ onUp(); window.removeEventListener('touchmove', touchMove); window.removeEventListener('touchend', touchEnd); }
}

// call when DOM is ready (script is at bottom so elements exist)
makeElementDraggable($('flipToolContainer'), $('toolHeader'));


</script>
</body>
</html>
